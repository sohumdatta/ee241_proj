The Muller C gate is a sequential circuit element which switches only when all its inputs have
the same value.
When the inputs disagree, the gate output retains its previous value.
\\
Any multi-input C gate can be expressed as a cascade of 2-input C gates
(henceforth MULLER).
This appendix describes the MULLER gate and derives its realization on 
the Xilinx Virtex-5 FPGA.
\\

Boolean expressions of sequential elements need special notation to distinguish the
current value and next value of signals. 
We denote both the signal and its current value by the signal name. 
Hence, $a$ denotes the value of signal 'a' at the present instant. 
Let $a'$ denote its value at the next instant and $\overline{a}$ its
logical negation. Then $a''$ will be the value of 'a' after $a'$.
Also, let $\oplus$, $\cdot$ and $+$ represent logical XOR, AND and OR respectively.
\\

The MULLER gate can be modelled as a latch which is transparent to one of its
inputs only when both of them agree:
\begin{equation} \label{eq:muller_c}
	\texttt{MULLER}(a,b)' = 
	\overline{(a \oplus b)} \cdot a\ +\ (a \oplus b) \cdot \texttt{MULLER}(a,b)
\end{equation}
%The C gate is the principal element of asynchronous circuits as it implements
%the indication principle -- it indicates a module to start working only when
%its inputs are ready. 
%\\

The Xilinx Virtex-5 FPGA contains 4 storage elements in each SLICE.
A storage element can be configured as a level-sensitive latch with input
driven by a LUT in the same SLICE. The latch is transparent when the control
signal clock \texttt{CLK} is LOW. Any latch element can either be used directly
as a 
\textsl{Transparent Data Latch with Asynchronous Clear and Present and Gate
Enable} (LDCPE) primitive or inferred by the Xilinx Synthesis Tool (XST).

A straightforward way of synthesizing MULLER on Virtex-5 would be to program
the LUT for the XOR signal $(a \oplus b)$ and connect its logical inverse to
\texttt{CLK}.

\subsection{C Gate using RS and SR Latches}
Although MULLER can be implemented by a single latch and LUT, it is prone
to spurious transitions in inputs. 
Using two latches reduces the risk of an output transition due to glitching.
A well known implementation of MULLER using RS and SR latches due to Murphy
[TODO: cite murphy] can be used for this purpose.

Both SR and RS latches have two inputs \texttt{set} (\texttt{S}) and
\texttt{reset} (\texttt{R}). 
SR latch is equivalent to the RS latch with \texttt{R} and \texttt{S} inputs
interchanged and the output inverted.
\begin{equation}\label{eq:rslatch}
	\texttt{RSLatch}(S,R)' = \overline{R} \cdot (S + \texttt{RSLatch}(S,R))
\end{equation}
\begin{equation}\label{eq:srlatch}
	\texttt{SRLatch}(S,R)' = S + \overline{R} \cdot \texttt{SRLatch}(S,R)
\end{equation}

For brevity $\texttt{MULLER}(a,b)$ is denoted by $c$. 
 One can easily simplify eqn. \ref{eq:muller_c} (using identity $x + \overline{x}
 \cdot y = x + y$ ) to obtain:
\begin{equation}\label{eq:muller_c_simplified}
\begin{split}
	\texttt{MULLER}(a,b)' &= c'\\
	&= (a \cdot b + \overline{a} \cdot \overline{b}) \cdot a 
		+ (a \cdot \overline{b} + \overline{a} \cdot b) \cdot c \\
	&= a \cdot (b + \overline{b} \cdot c) + \overline{a} \cdot b \cdot c \\
	&= a \cdot c + b \cdot (a + \overline{a} \cdot c) \\
	&= a \cdot b + a \cdot c + b \cdot c
\end{split}
\end{equation}
To express MULLER in terms of SR and RS latches, 
observe that eqn. \ref{eq:muller_c_simplified} contains only true values of
inputs but \texttt{R} appears in both SR and RS latches (eqs. \ref{eq:srlatch}
and \ref{eq:rslatch}) as $\overline{R}$. 
Hence, \texttt{R} of the latches will be $\overline{a}$ or $\overline{b}$.
Only the expression for RS latch (eqn. \ref{eq:rslatch}) has a minterm containing both \texttt{R}
and \texttt{S}, which will produce the minterm $ a \cdot b $ in eqn. \ref{eq:muller_c_simplified}.
\\
Therefore, the RS latch appears in the first stage producing the minterms $a
\cdot b$ and $a \cdot c$ or $b \cdot c$ (depending on \texttt{R} being
$\overline{a}$ or $\overline{b}$ respectively). 
The SR latch forms the second stage.
Since \texttt{S} appears alone in its expression, we connect the RS output
to \texttt{S} and the input other than \texttt{R} of previous stage to the
\texttt{R} of the second stage.

Representing the RS output by $p$ and the subsequent SR output by $q$,
we have:
\begin{equation}\label{eq:muller_rs}
\begin{split}
	\texttt{RSLatch}(S=a, R=\overline{b}) &= p' = a \cdot b + b \cdot p \\
	\texttt{SRLatch}(S=p, R=\overline{a}) &= q' = p + a \cdot q \\
	%q' &= a \cdot b + b \cdot p + a \cdot q
\end{split}
\end{equation}
From above, we have $q'' = p' + a' \cdot q' = (a \cdot b + b \cdot p) + 
a' \cdot (p + a \cdot q)$. 
Assuming input steady state i.e.\ $a'' = a' = a$ and $b'' = b' = b$, we have:
\begin{equation}
\begin{split}
	q''& = a \cdot b + a \cdot p + b \cdot p + a \cdot q\\
	&= a \cdot b \cdot (1 + q) + (a + b ) \cdot p + a \cdot q\\
	&= a \cdot b + (a + b ) \cdot p + a \cdot q + a \cdot b \cdot q\\
	&= a \cdot b + (a + b ) \cdot p + (a + b) \cdot a \cdot q\\
	&= a \cdot b + (a + b ) \cdot (p + a \cdot q)\\
	&= a \cdot b + (a + b ) \cdot q'
\end{split}
\end{equation}
This proves the equivalence of the pair latch (eqn. \ref{eq:muller_rs}) to MULLER
(eqn. \ref{eq:muller_c_simplified}).
\\
It may appear that the heurestic used to connect the pair just happened to
prove equivalent to MULLER. 
However, the circuit really was synthesized using reductions on a 
Signal Transition Graphs (STG) specification [TODO: cite murphy]. 
STGs are directed graphs with nodes corresponding to minterms in eqn.
\ref{eq:muller_c_simplified} [TODO: Find citation]. 
The synthesis algorithm does something similar to matching leaf nodes of the
latch STGs with that of MULLER -- like our heurestic [TODO: Find
citation]. 
Also, note that the difference of SR and RS latch expressions (eqs.
\ref{eq:srlatch} and \ref{eq:rslatch}) helped using the heurestic. 
Though an RS latch can be converted to SR latch easily, it would be much harder
to build the pair using 2 SR latches.
